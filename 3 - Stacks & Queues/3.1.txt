Describe how you could use a single array to implement three stacks.

I would use a method similar to storing a 2+d matrix in a 1d array - Instead of allocating a static offset and listing all n rows of the matrix one after another, I would use the first element in the array to store the current max size of the stacks. This would increase and decrease dynamically, similar to how arrays themselves are resized in many languages (like Java). This would ensure that no stack's data ever overwrote another, as well as ensuring that earlier stacks didn't push others down any more often than necessary - if this were to happen on every push(), the performance hit would be immense.
The next three elements of the array would contain the index of the top element of each stack. Following this would be the three stacks themselves, separated by a number of empty slots (based on the currently allocated space per stack and the number of existing elements in each).
A pop() would be a simple lookup of the corresponding stack's top element's index, followed by the actual retrieval. A push() would generally consist of inserting the data and incrementing the index of the top element, but in rare cases would require the size per stack value to change. The array itself would be resized, and all following stacks would be shuffled down to make more space. The reverse would obviously happen when enough elements were popped from all stacks as to put them below a similar threshold (on second thought this may require a min stack size value to be stored as well as the max).
This method could be scaled to support any number of stacks, although obviously performance suffers a little with each additional stack as a resize event would require the moving of more data entries.